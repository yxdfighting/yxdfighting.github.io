---
title: C++11新特性
---
内容主要来自于C++ primer第五版
#### lambda表达式
> 向算法传递函数  

**1.谓词**  
谓词是一个可调用的表达式，其返回结果是一个能用做条件的值。分为一元谓词与二元谓词（根据接受的参数数量),接受谓词的算法对输入序列中的每个元素调用谓词，因此元素类型必须能够转化为谓词的参数类型。  
bool isShorter(const string &s1,const string &s2)  
{  
     return s1.size()<s2.size();  
}  

sort(words.begin(),words.end(),isShorter);  
同样的，我们可以使用find_if()算法来查找第一个具有特定大小的元素，find_if参数为一对迭代器，第三个参数可以为一个谓词，find_if为每个
输入序列中的元素调用这个谓词；但find_if只接受一元谓词，但我们的函数需要的输入有string、一个给定大小的数字，不符合条件，所以lambda表达式应运而生。  
> 
**2.lambda表达式**  
lambda是一个可调用对象，其本质上是一个未命名的内联函数，一个lambda表达式具有如下形式：  
[capture list] (parameter list) ->return type {function body}
[capture list]是函数中所定义的局部变量的列表(通常为空),剩余部分与常用函数相同。->在表达式有返回值时用到  
举个栗子：  
auto f = [ ]{ return 42; };  
cout << f() << endl;  

[ ]{const string &s1,const string &s2}{ return s1.size() < s2.size() ; }  
[sz] (const string &s){return }{return s.size() >= sz ;}; //一个lambda只有在其捕获列表中捕获一个它所在函数中的局部变量，才能在函数体中使用该变量。  

>
**3.lambda捕获和返回**  
当向一个函数传递一个lambda时，同时定义了一个新类型和该类型的一个对象，传递的参数就是此编译器生成的类类型的未命名对象  
1.值捕获和引用捕获  
捕获值列表，是允许我们在Lambda表达式的函数体中直接使用这些值，捕获值列表能捕获的值是所有在此作用域可以访问的值，包括这个作用域里面的临时变量，类的可访问成员，全局变量。**Lambda表达式通过在最前面的方括号[]来明确指明其内部可以访问的外部变量，这一过程也称过Lambda表达式“捕获”了外部变量。**捕获值的方式分两种，一种是按值捕获，一种是按引用捕获。顾名思义，按值捕获是不改变原有变量的值，按引用捕获是可以在Lambda表达式中改变原有变量的值。  
2.隐式捕获
为了指示编译器推断捕获列表，应在捕获列表中写一个&或者=。前者表示引用捕获，后者表示值捕获。  
10.21  [&a] ( ) mutable->bool {a--; return a == 0 ? false : true; }()




#### long long类型
在32位系统上，int、long、long long、size_t字节数分别为4、4、8、8；在64位机器上，四者依次为4、8、8、8
#### 列表初始化
int a = {0};  
int a{0};  
在C++11中，列表初始化得到了全面应用，无论是在初始化对象时，还是为对象赋新值时，都可以使用，并且还有相应的好处，那就是在对内置数据类型进行列表初始化时，如果有数据丢失风险时，编译器会报错。
#### nullptr常量
关于nullptr与NULL区别,nullptr是C++11中新定义的字面值常量，可以转换为任意类型的指针，NULL是预处理变量，其值为0，运行在编译过程之前。
#### 类型别名声明
传统采用typedef关键字，C++11中可以使用using作为别名声明的开始，例如：using SI = Sales_item；
#### auto
在C++11中引入了auto类型说明符，可以让编译器替我们去分析表达式所属的类型，auto让编译器通过初始值来推算变量的类型


